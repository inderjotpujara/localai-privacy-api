# All-in-One LocalAI Privacy API Docker Image
# This image contains all services: API, Database, LocalAI, Monitoring Stack
# Built for single-command deployment

FROM node:18-bullseye as api-builder

# Install API dependencies and build
WORKDIR /app/api
COPY api/package*.json ./
RUN npm ci

COPY api/ ./
RUN npm run build

FROM ubuntu:22.04

# Avoid interactive prompts during package installation
ENV DEBIAN_FRONTEND=noninteractive

# Install system dependencies
RUN apt-get update && apt-get install -y \
    curl \
    wget \
    supervisor \
    sqlite3 \
    # LocalAI dependencies
    python3 \
    python3-pip \
    # Monitoring dependencies
    curl \
    unzip \
    # Node.js dependencies
    && curl -fsSL https://deb.nodesource.com/setup_18.x | bash - \
    && apt-get install -y nodejs \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Create application directories
RUN mkdir -p /app/api /app/data /app/models /app/logs /app/config

# Copy API from builder
COPY --from=api-builder /app/api/dist /app/api/dist
COPY --from=api-builder /app/api/node_modules /app/api/node_modules
COPY --from=api-builder /app/api/package*.json /app/api/

# Install LocalAI
RUN wget -O /usr/local/bin/local-ai https://github.com/mudler/LocalAI/releases/download/v2.20.0/local-ai-Linux-x86_64 \
    && chmod +x /usr/local/bin/local-ai

# Install Grafana
RUN wget -q -O - https://apt.grafana.com/gpg.key | apt-key add - \
    && echo "deb https://apt.grafana.com stable main" | tee -a /etc/apt/sources.list.d/grafana.list \
    && apt-get update \
    && apt-get install -y grafana \
    && apt-get clean

# Install Loki and Promtail
RUN wget https://github.com/grafana/loki/releases/download/v2.9.0/loki-linux-amd64.zip \
    && unzip loki-linux-amd64.zip \
    && mv loki-linux-amd64 /usr/local/bin/loki \
    && chmod +x /usr/local/bin/loki \
    && rm loki-linux-amd64.zip

RUN wget https://github.com/grafana/loki/releases/download/v2.9.0/promtail-linux-amd64.zip \
    && unzip promtail-linux-amd64.zip \
    && mv promtail-linux-amd64 /usr/local/bin/promtail \
    && chmod +x /usr/local/bin/promtail \
    && rm promtail-linux-amd64.zip

# Install sqlite-vec for vector similarity search
RUN pip3 install sqlite-vec

# Copy models and configurations
COPY models/ /app/models/
COPY infra/ /app/config/

# Create SQLite database initialization script
COPY <<EOF /app/init-sqlite.sql
-- Enable vector extension (will be handled by sqlite-vec)
-- Create documents table for RAG
CREATE TABLE IF NOT EXISTS documents (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    content TEXT NOT NULL,
    metadata TEXT DEFAULT '{}',
    embedding BLOB, -- Vector embeddings stored as BLOB
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Create user sessions table
CREATE TABLE IF NOT EXISTS user_sessions (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    user_id TEXT NOT NULL,
    session_data TEXT DEFAULT '{}',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    expires_at DATETIME
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_documents_created_at ON documents(created_at);
CREATE INDEX IF NOT EXISTS idx_user_sessions_user_id ON user_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_user_sessions_expires_at ON user_sessions(expires_at);
EOF

# Create SQLite database adapter
COPY <<EOF /app/api/src/services/database-sqlite.ts
import sqlite3 from 'sqlite3';
import { Database as SqliteDatabase, open } from 'sqlite';
import pino from 'pino';
import { Document, RAGResult } from '../types';

const logger = pino();

export class Database {
  private db: SqliteDatabase | null = null;
  private initialized = false;

  constructor() {
    // SQLite doesn't need connection configuration like PostgreSQL
  }

  async initialize(): Promise<void> {
    if (this.initialized) return;

    try {
      // Open SQLite database
      this.db = await open({
        filename: '/app/data/localai.db',
        driver: sqlite3.Database
      });

      // Load sqlite-vec extension
      await this.db.exec("SELECT load_extension('/usr/local/lib/python3.10/dist-packages/sqlite_vec.so')");

      // Initialize tables
      const initSql = require('fs').readFileSync('/app/init-sqlite.sql', 'utf8');
      await this.db.exec(initSql);

      this.initialized = true;
      logger.info('SQLite database initialized successfully');

    } catch (error) {
      logger.error('Database initialization failed:', error);
      throw error;
    }
  }

  async insertDocument(content: string, metadata: Record<string, any> = {}, embedding?: number[]): Promise<string> {
    if (!this.db) throw new Error('Database not initialized');
    
    try {
      const id = this.generateId();
      const embeddingBlob = embedding ? Buffer.from(new Float32Array(embedding).buffer) : null;
      
      await this.db.run(
        'INSERT INTO documents (id, content, metadata, embedding) VALUES (?, ?, ?, ?)',
        [id, content, JSON.stringify(metadata), embeddingBlob]
      );
      
      return id;
    } catch (error) {
      logger.error('Error inserting document:', error);
      throw error;
    }
  }

  async searchSimilarDocuments(
    queryEmbedding: number[], 
    limit: number = 5, 
    similarityThreshold: number = 0.7
  ): Promise<RAGResult[]> {
    if (!this.db) throw new Error('Database not initialized');
    
    try {
      // For now, return all documents (simplified similarity search)
      // In production, you'd implement proper vector similarity with sqlite-vec
      const rows = await this.db.all(
        'SELECT id, content, metadata FROM documents WHERE embedding IS NOT NULL LIMIT ?',
        [limit]
      );
      
      return rows.map(row => ({
        content: row.content,
        metadata: JSON.parse(row.metadata || '{}'),
        similarity_score: 0.8, // Mock similarity score
        document_id: row.id
      }));
      
    } catch (error) {
      logger.error('Error searching similar documents:', error);
      throw error;
    }
  }

  async getDocumentById(id: string): Promise<Document | null> {
    if (!this.db) throw new Error('Database not initialized');
    
    try {
      const row = await this.db.get(
        'SELECT id, content, metadata, created_at, updated_at FROM documents WHERE id = ?',
        [id]
      );
      
      if (!row) return null;
      
      return {
        id: row.id,
        content: row.content,
        metadata: JSON.parse(row.metadata || '{}'),
        created_at: new Date(row.created_at),
        updated_at: new Date(row.updated_at)
      };
      
    } catch (error) {
      logger.error('Error getting document by ID:', error);
      throw error;
    }
  }

  async updateDocument(id: string, content?: string, metadata?: Record<string, any>, embedding?: number[]): Promise<boolean> {
    if (!this.db) throw new Error('Database not initialized');
    
    try {
      const updates: string[] = [];
      const values: any[] = [];

      if (content !== undefined) {
        updates.push('content = ?');
        values.push(content);
      }

      if (metadata !== undefined) {
        updates.push('metadata = ?');
        values.push(JSON.stringify(metadata));
      }

      if (embedding !== undefined) {
        updates.push('embedding = ?');
        values.push(Buffer.from(new Float32Array(embedding).buffer));
      }

      if (updates.length === 0) {
        return false;
      }

      updates.push('updated_at = CURRENT_TIMESTAMP');
      values.push(id);

      const result = await this.db.run(
        `UPDATE documents SET ${updates.join(', ')} WHERE id = ?`,
        values
      );
      
      return (result.changes ?? 0) > 0;
      
    } catch (error) {
      logger.error('Error updating document:', error);
      throw error;
    }
  }

  async deleteDocument(id: string): Promise<boolean> {
    if (!this.db) throw new Error('Database not initialized');
    
    try {
      const result = await this.db.run('DELETE FROM documents WHERE id = ?', [id]);
      return (result.changes ?? 0) > 0;
      
    } catch (error) {
      logger.error('Error deleting document:', error);
      throw error;
    }
  }

  async close(): Promise<void> {
    if (this.db) {
      await this.db.close();
      logger.info('Database connections closed');
    }
  }

  async isHealthy(): Promise<boolean> {
    try {
      if (!this.db) return false;
      await this.db.get('SELECT 1');
      return true;
    } catch (error) {
      logger.error('Database health check failed:', error);
      return false;
    }
  }

  private generateId(): string {
    return Math.random().toString(36).substring(2) + Date.now().toString(36);
  }
}
EOF

# Install SQLite dependencies for Node.js
WORKDIR /app/api
RUN npm install sqlite3 sqlite

# Create configuration files
COPY <<EOF /app/config/supervisord.conf
[supervisord]
nodaemon=true
user=root
logfile=/app/logs/supervisord.log
pidfile=/app/logs/supervisord.pid

[program:api]
command=node /app/api/dist/server.js
directory=/app/api
autostart=true
autorestart=true
stdout_logfile=/app/logs/api.log
stderr_logfile=/app/logs/api.log
environment=NODE_ENV=production,DATABASE_URL=sqlite:///app/data/localai.db,LOCALAI_URL=http://localhost:8080,PORT=3000,JWT_SECRET=all-in-one-jwt-secret-change-in-production

[program:localai]
command=/usr/local/bin/local-ai --address=0.0.0.0:8080 --models-path=/app/models --context-size=4096
directory=/app
autostart=true
autorestart=true
stdout_logfile=/app/logs/localai.log
stderr_logfile=/app/logs/localai.log

[program:loki]
command=/usr/local/bin/loki -config.file=/app/config/loki/local-config.yaml
directory=/app
autostart=true
autorestart=true
stdout_logfile=/app/logs/loki.log
stderr_logfile=/app/logs/loki.log

[program:grafana]
command=/usr/share/grafana/bin/grafana-server --homepath=/usr/share/grafana --config=/app/config/grafana/grafana.ini
directory=/app
autostart=true
autorestart=true
stdout_logfile=/app/logs/grafana.log
stderr_logfile=/app/logs/grafana.log
user=grafana

[program:promtail]
command=/usr/local/bin/promtail -config.file=/app/config/promtail/config.yml
directory=/app
autostart=true
autorestart=true
stdout_logfile=/app/logs/promtail.log
stderr_logfile=/app/logs/promtail.log
EOF

# Create simplified Grafana config
COPY <<EOF /app/config/grafana/grafana.ini
[paths]
data = /app/data/grafana
logs = /app/logs
plugins = /app/data/grafana/plugins
provisioning = /app/config/grafana

[server]
http_port = 3001
domain = localhost

[security]
admin_user = admin
admin_password = admin

[users]
allow_sign_up = false
EOF

# Create Loki config for single node
COPY <<EOF /app/config/loki/local-config.yaml
auth_enabled: false

server:
  http_listen_port: 3100
  grpc_listen_port: 9096

common:
  path_prefix: /app/data/loki
  storage:
    filesystem:
      chunks_directory: /app/data/loki/chunks
      rules_directory: /app/data/loki/rules
  replication_factor: 1
  ring:
    instance_addr: 127.0.0.1
    kvstore:
      store: inmemory

query_scheduler:
  max_outstanding_requests_per_tenant: 2048

schema_config:
  configs:
    - from: 2020-10-24
      store: boltdb-shipper
      object_store: filesystem
      schema: v11
      index:
        prefix: index_
        period: 24h
EOF

# Create Promtail config
COPY <<EOF /app/config/promtail/config.yml
server:
  http_listen_port: 9080
  grpc_listen_port: 0

positions:
  filename: /app/data/promtail/positions.yaml

clients:
  - url: http://localhost:3100/loki/api/v1/push

scrape_configs:
  - job_name: system
    static_configs:
      - targets:
          - localhost
        labels:
          job: localai-all-in-one
          __path__: /app/logs/*.log
EOF

# Create startup script
COPY <<EOF /app/start.sh
#!/bin/bash
set -e

echo "🚀 Starting LocalAI All-in-One Container..."

# Create data directories
mkdir -p /app/data/grafana /app/data/loki/chunks /app/data/loki/rules /app/data/promtail

# Initialize SQLite database
echo "🗄️ Initializing SQLite database..."
sqlite3 /app/data/localai.db < /app/init-sqlite.sql

# Set proper permissions
chown -R grafana:grafana /app/data/grafana
chmod -R 755 /app/data
chmod -R 755 /app/logs

echo "✅ All services starting via supervisord..."
echo ""
echo "📊 Service URLs:"
echo "  - API: http://localhost:3000"
echo "  - LocalAI: http://localhost:8080" 
echo "  - Grafana: http://localhost:3001 (admin/admin)"
echo ""

exec /usr/bin/supervisord -c /app/config/supervisord.conf
EOF

RUN chmod +x /app/start.sh

# Expose ports
EXPOSE 3000 3001 8080

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:3000/health && curl -f http://localhost:8080/health

# Set working directory
WORKDIR /app

# Start all services
CMD ["/app/start.sh"]
